#include <iostream>

using namespace std;
/*НАША СТРУКТУРА*/
struct Stack
{
	int x;                                              //информационный элемент
	Stack* Next, * Head;                                   //Голова стека и указатель на следующий элемент
};

/*ФУНКЦИЯ ДОБАВЛЕНИЯ ЭЛЕМЕНТА В СТЕК (в список LIFO)*/
void Push(int x, Stack*& MyList)                          //Принимаем элемент стека и указатель на стек, при этом говорим, что принимаемый указатель будет сам по себе указателем
{
	Stack* temp = new Stack;                              //Выделяем память для нового элемента
	temp->x = x;                                        //Записываем в поле x принимаемый в функцию элемент x
	temp->Next = MyList->Head;                          //Указываем, что следующий элемент это предыдущий
	MyList->Head = temp;                                //Сдвигаем голову на позицию вперед
}

/*ФУНКЦИЯ ОТОБРАЖЕНИЯ СТЕКА*/
void Show(Stack* MyList)                                 //Нужен только сам стек
{
	Stack* temp = MyList->Head;                          //Объявляем указатель и Указываем ему, что его позиция в голове стека
	//с помощью цикла проходим по всему стеку
	while (temp != NULL)                                //выходим при встрече с пустым полем
	{
		cout << temp->x << " ";                         //Выводим на экран элемент стека
		temp = temp->Next;                              //Переходим к следующему элементу
	}
}

/*ФУНКЦИЯ УДАЛЕНИЯ СТЕКА ИЗ ПАМЯТИ*/
void ClearStack(Stack* MyList)
{
	while (MyList->Head != NULL)                        //Пока по адресу не пусто
	{
		Stack* temp = MyList->Head->Next;                    //Временная переменная для хранения адреса следующего элемента
		delete MyList->Head;                                //Освобождаем адрес обозначающий начало
		MyList->Head = temp;                                //Меняем адрес на следующий
	}
}

void Pop(int N, Stack* MyList) {//функция которая принимает вершину top и число которое нужно удалить
	Stack* q = MyList->Head; //создаем указатель типа comp и приравниваем(ставим) его на вершину стека
	Stack* prev = NULL;//создаем указатель на предыдуший элемент, с начала он будет пустым
	while (q != NULL) {//пока указатель q не пустой, мы будем выполнять код в цикле, если он все же пустой цикл заканчивается
		if (q->x == N) {//если Data элемента равна числу, которое нам нужно удалить
			if (q == MyList->Head) {//если такой указатель равен вершине, то есть элемент, который нам нужно удалить - вершина
				MyList->Head = q->Next;//передвигаем вершину на следующий элемент
				free(q);//очищаем ячейку
				q->x= NULL; //Далее во избежание ошибок мы обнуляем переменные в удаленной ячейке, так как в некоторых компиляторах удаленная ячейка имеет переменные не NULL значения, а дословно "Чтение памяти невозможно" или числа  "-2738568384" или другие, в зависимости от компилятора.
				q->Next = NULL;
			}
			else//если элемент последний или находится между двумя другими элементами
			{
				prev->Next = q->Next;//Проводим связь от предыдущего элемента к следующему
				free(q);//очищаем ячейку 
				q->x = NULL;//обнуляем переменные
				q->Next = NULL;
			}
		}// если Data элемента НЕ равна числу, которое нам нужно удалить
		prev = q; //запоминаем текущую ячейку как предыдущую
		q = q->Next;//перемещаем указатель q на следующий элемент
	}
}

int main()
{
	Stack* MyList = new Stack; //Выделяем память для стека


	MyList->Head = NULL; //Во избежание ошибок инициализируем первый элемент

	for (int i = 0; i < 10; i++) Push(i, MyList); //Заносим данные в стек
	Show(MyList); //Выводим стек на экран

	ClearStack(MyList); //Очищаем память.
	delete MyList->Head;
	delete MyList;
}